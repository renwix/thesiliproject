#!/usr/bin/perl

use File::Path;
use POSIX qw( setid :sys_wait_h );
use Sili::ERS::DB;
use Sili::ERS::Environment;
use Sili::ERS::Heuristic;
use Sili::ERS::PidMap;
use Sili::ERS::ProcessInfo;
use Sili::ERS::Node;
use Sili::ERS::Utils;
use Sili::Ness;

defineScript
  "Engine for Running Stuff (ERS) will query a DB to find work to do and execute it, saving state in the DB, and STDIO on disk. It provides a transactional way to run jobs."
    param( tag => 'user:s',
           var => '$dbuser',
           default => '$ENV{DATABASE_USER)',
           doc => 'db user'),
    param( tag => 'host:s',
           var => '$dbhost',
           default => '$ENV  param(DATABASE_HOST)',
           doc => 'db machine'),
    param( tag => 'passwd:s',
           var => '$passwd',
           default => '$ENV  param(DATABASE_PASSWD)',
           doc => 'db passwd'),
    param( tag => 'sid:s',
           var => '$sid',
           default => '$ENV  param(DATABASE_SID)',
           doc => 'db sid'),
    param( tag => 'port:s',
           var => '$port',
           default => '$ENV  param(DATABASE_PORT)',
           doc => 'db port'),
    param( tag => 'logRoot:s',
           var => '$logRoot',
           required => 1,
           doc => 'The location for the STDIO logs generated by the child processes. They will be create a hierarchy off this root that follows the graph hierarchy'),
    param( tag => 'sleepDelay:s',
           var => '$sleepDelay',
           default => 10,
           doc => 'The amount of time (seconds) that the process should sleep for if there is no work in its queue. When it wakes, it checks the queue for work again.'),
    param( tag => 'persistenceModel:s',
           var => '$persistenceModel',
           default => 'Oracle',
           doc => 'The name of the class that implements the Sili::ERS::DB interface that should be used for this execution.'),
    param( tag => 'heuristicsModel:s',
           var => '$heuristicsModel',
           default => 'FirstModel',
           doc => 'The tool used to determine how node transitions occur.'),
    param( tag => 'runAndExit',
           var => '$runAndExit',
           doc => 'When there are no more nodes in memory, just exit. This is great for tests and 1 time deals.'),
    ;

# Logging
$| = 1; # no buffering

# Load our persistence model
my $persistence;
eval "
use Sili::ERS::DB::$persistenceModel; 
\$persistence = new Sili::ERS::DB::$persistenceModel( user => \"$dbuser\",
                                                   password => \"$passwd\",
                                                   SID => \"$sid\",
                                                   host => \"$dbhost\",
                                                   port => \"$port\",
                                                   debug => $debug);
";
Confess "unable to load persistenceModel '$persistenceModel': $@" if $@;



#
# Load our heuristics model. Heuristics are MDO now, so there is a lot
# of external config potential. However, in the first implementation, the
# config has to be "statically" defined in a class somewhere. That class
# is then 'required' by this engine.
#
# my $heuristicsEngine;
# eval "
# use Sili::ERS::Heuristic::$heuristicsModel; 
# \$heuristicsEngine = new Sili::ERS::Heuristic::$heuristicsModel();
# ";
# Confess "unable to load heuristicsModel '$heuristicsModel': $@" if $@;



#
# A PidMap is the memory space for what the engine is processing
# 
my $pidMap = new Sili::ERS::PidMap();



#
# Signal handlers
#
# This is used for the multi-threading aspect of this engine.
# From a code perspective, these have to be defined after the
# $pidMap so that they can close on the reference to that object.
# 
logMessage( node => undef, 
            level => 1, 
            message => "registering signal handlers" );
my $signal_quiesced = 0;

sub REAPER {
    my $pid;
    while (($pid = waitpid(-1, &WNOHANG)) > 0) {
	$exit_value  = $? >> 8;
	$signal_num  = $? & 127;
	$dumped_core = $? & 128;

	if ($pid == -1) {
	    # no child waiting.  Ignore it.
	} elsif (WIFEXITED($?)) {
	    logMessage(node => undef, 
                       level => 1, 
                       message => "Process $pid exited");
	} else {
	    logMessage(node => undef, 
                       level => 1, 
                       message => "false alarm on $pid");
	}
        my $node = $pidMap->get( pid => $pid );
        $node->setReturnCode( $exit_value );
        $node->setSignalNum( $signal_num );
        $node->setReapable( 1 );
    }

    $SIG{CHLD} = \&REAPER;            # install *after* calling waitpid
}
$SIG{CHLD} = \&REAPER;

#
# This is on SIGHUP because in this model, we never reload the graph/env files.
# in that case, we always create a new node.
# 
sub QUIESCE {
    $signal_quiesced = 1;
    logMessage(node => undef, 
               level => 1, 
               message => "quiesced (SIGHUP), will exit as soon as no tasks are running (not accepting new requests)");
    # no real point in reinstalling the sig handler.
}
$SIG{HUP} = \&QUIESCE; 


#
# don't catch SIGINT, just let perl handle that for us
# 

sub DUMPMEMSTATE {
    logMessage( node => undef, 
                level => 0, 
                message => $pidMap->toString() );
}
$SIG{USR1} = \&DUMPMEMSTATE;

sub INCREASEDEBUGGING {
    $debug++;
    logMessage( node => undef, 
                level => 0, 
                message => "increasing the debug level to $debug" );
}
$SIG{USR2} = \&INCREASEDEBUGGING;

logMessage( node => undef, 
            level => 1, 
            message => "Completed registering signal handlers" );
#
# End Signal Handlers
# 






#
# Recover from a previous shutdown state
#
# These will be disconnected from the signal handler, so we have
# to set up special to watch these.
#
logMessage(node => undef, 
           level => 1, 
           message => "Checking for previous failures.");
for my $node ( $persistence->getNodesInState( state => 'running' ) ) {
    $node->watchPid( pidMap => $pidMap );
}



#
# And the main process
# 
my $longProcessSleepDelay = 1;
my $longProcessSleepIterations = 0;
while (1) {
    
    #
    # cleanup anyone who has finished processing
    # 
    my @reapable = $pidMap->getReapableNodes;
    for my $node (@reapable) {
        $node->reap( dbh => $persistence,
                     pidMap => $pidMap );
#         $heuristicsEngine->apply( node => $node,
#                                   persistence => $persistence );
    }

    #
    # get the new nodes
    # 
    for my $node ( $persistence->getNodesInState( state => 'new' ) ) {

        #
        # And execute them
        # 
        $node->setLogRoot( $logRoot );
        eval {
            $node->execute( dbh => $persistence, 
                            pidMap => $pidMap );
        }; if ($@) {
            #
            # It should be hard to get here. 
            # Only an exec error would cause it (in theory).
            # and that is probably due to an extra large environment.
            # 
            $node->setReturnCode( -1 );
            $node->setPid( -1 );
            $node->reap( dbh => $persistence, 
                         pidMap => $pidMap, 
                         errorMessage => $@ );
        }
    }


    #
    # Loop starts again after a time unless we have been quiesed or
    # asked to exit when we are done processing.
    # 
    cleanup 0 if $signal_quiesced;
    cleanup 0 if ! $pidMap->runningPidsExist() && $runAndExit;

    unless ($pidMap->runningPidsExist()) {
        $longProcessSleepIterations = 0;
        $longProcessSleepDelay = 1;
        logMessage(node => undef, 
                   level => 1, 
                   message => "Nothing to do, going to sleep for $sleepDelay" );
        sleep $sleepDelay;
    } else {
        #
        # In the case of running pids, and no new work, we want to
        # slowly back off the frequency that the thing checks for new work.
        # 
        $longProcessSleepIterations++;
        sleep $longProcessSleepDelay;
        if ($longProcessSleepIterations > 2 && $longProcessSleepIterations < 6) { # 4 times only ~ 15 secs max
            $longProcessSleepDelay += $longProcessSleepDelay;
            logMessage( node => undef, 
                        level => 1, 
                        message => "backing off logging: $longProcessSleepDelay, $longProcessSleepIterations" );
        }
    }
}

cleanup 0; 
