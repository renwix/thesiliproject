#!/usr/bin/perl

# gpl
# 
#  Author: Renwix (renwix@gmail.com)
#  Maintainer: Renwix
#  Copyright (C) 2008 Renwix, all rights reserved.
#  Created: Tue Sep 23 23:52:17 MDT 2008
# 
# 
#=======================================================================
# 
# This file is part of theSiliProject, a humorous software organization,
# design and development toolkit.
# 
# theSiliProject is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# theSiliProject is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with theSiliProject. If not, see <http://www.gnu.org/licenses/>.
# 
#=======================================================================
# 
# /gpl

use Carp;
use Getopt::Long;
use Data::Dumper;
use Pod::Usage;
use Directive;
use File::Basename;
use Term::ANSIColor qw(:constants);
our ($trace, $debug);


sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$) @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$) @_\n" ;
}

sub docmdi {    
    printmsg "@_";
    system(@_);

    my $rc = 0;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - ignoring\n";
        }
    }
    return $rc;
}

sub docmd (@) {    
    printmsg "@_" ;
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub cleanup ($@) { 
    my $exit_code = shift;
    debugPrint( 1, @_ ) if scalar @_;
    debugPrint( 1, "exiting with exit code = $exit_code" );
    exit $exit_code;
}

sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Croak (@) {croak BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, "@_", RESET }

my $output;
$output = $ENV{output} if $ENV{output};
my $file;
$file = $ENV{file} if $ENV{file};
my $keep;
$keep = $ENV{keep} if $ENV{keep};
my $fileExtensionMapDB;
$fileExtensionMapDB = $ENV{fileExtensionMapDB} if $ENV{fileExtensionMapDB};
$trace = "0";
$trace = $ENV{trace} if $ENV{trace};
$debug = "0";
$debug = $ENV{debug} if $ENV{debug};
my $help = "0";
$help = $ENV{help} if $ENV{help};

GetOptions(
	'source|file=s'	=> \$file,
  'destination|output:s'	=> \$output,
	'keep'	=> \$keep,
	'trace'	=> \$trace,
	'debug+'	=> \$debug,
	'help'	=> \$help,
  'xtensionMapDB:s' => \$fileExtensionMapDB,
           );

printUsage() if $help;
unless ($file) { 
    if (@ARGV) {
        $file = shift;
    } else {
        printmsg "file is required" ; printUsage() ; 
    } 
}

sub debugPrint ($@) { 
    my $level = shift;
    if ($debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub printUsage {
    if (scalar @_ > 0) {
        print STDERR "@_\n";
        exit(1);
    } else {
        pod2usage({ -exitval => 1, 
                    -verbose => ($debug ? $debug : 1),
                    -output  => \*STDERR});
    }
}

=pod

=head1 NAME

xfmPipe.pl - Given a directive in a file, run all the steps that it defines.

=head1 SYNOPSIS

    > xfmPipe.pl [OPTIONS] --file <file> --output <file>
    
=head1 ARGUMENTS

=over 4

=item [REQUIRED] 'file|input:s'

The file to process


=item 'destination|output:s'

The output file


=item 'keep'

Keep the intermediate files


=item 'trace'

The $trace command line flag turns on trace functionality


=item 'debug+'

The $debug command line flag is additive and can be used with the &debugPrint subroutine


=item 'help'

The help command line flag will print the help message

=cut

# ## This is autogenerated documentation
$file || printUsage();

unless ($output) {
    ($output = $file) =~ s/.xfm$//;
}
debugPrint(1, "creating $output from $file");

my $d = new Directive( inputFile => $file,
                       outputFile => $output,
                       keep => $keep,
                       fileExtensionMapDB => $fileExtensionMapDB,
                       );
$d->process();

cleanup 0; # "
