# gpl
# 
#  Author: Renwix (renwix@gmail.com)
#  Maintainer: Renwix
#  Copyright (C) 2008 Renwix, all rights reserved.
#  Created: Tue Sep 23 23:52:17 MDT 2008
# 
# 
#=======================================================================
# 
# This file is part of theSiliProject, a humorous software organization,
# design and development toolkit.
# 
# theSiliProject is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# theSiliProject is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with theSiliProject. If not, see <http://www.gnu.org/licenses/>.
# 
#=======================================================================
# 
# /gpl

=pod

=head1 NAME - Directive

This thing is supposed to take an input file and produce an output
file that has gone through the specified transformations.

                                   

=head1 EXAMPLE


  my $Directive = $Directive->new();   # stub example .... expand
  $Directive->setInputFile( $filename );
  $Directive->setOutputFile( $filename );
  $Directive->setTmpDir( '/a/different/tmp/dir' ); # defaults to /tmp
  $Directive->process();


=cut


# THIS FILE IS AUTO-GENERATED! DO NOT EDIT THIS FILE!


package Directive;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use UNIVERSAL qw(isa can);
use strict;
our (@ISA);
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Croak (@) {croak BOLD, RED, @_, RESET}

use File::Basename;

sub printmsg (@) { 
  my $date = localtime;
  print STDERR $date . ":" . basename($0) . ":($$) @_.\n" ;
}

sub printmsgn (@) { 
  my $date = localtime;
  print STDERR $date . ":" . basename($0) . ":($$) @_\n" ;
}

use English;
{
	my $_class_attrs = {
		inputFile => undef,
		outputFile => undef,
		tmpDir => undef,
		commands => undef,
		directive => undef,
		fileExtensionMapDB => undef,
		keep => undef,
		_currentIterator => undef,
		debug => undef,
	};
	sub _class_attrs {  }
}

=pod

=head1 CONSTRUCTOR

=over 4

=item Directive->new()

initializes on object of type Directive

=back

=cut


#
# _allMemberAttributes | _allSetters
#
# This class is generated from PerlObject which is a declaration of
# everything that makes up a class. That is - it gives declaritive
# syntax for all object members, docs, defaults etc. That information
# gets cached with each class for interrogation via a "reflectionAPI".
# That API relies on these static structures.
# 

my %_allSetters = ();
my %_allMemberAttributes = ();
$_allMemberAttributes{inputFile} = {
          'name' => 'inputFile',
          'description' => 'The input file that should be processed'
        }
;
$_allSetters{inputFile} = \&setInputFile;
$_allMemberAttributes{outputFile} = {
          'name' => 'outputFile',
          'description' => 'The output file that should be created'
        }
;
$_allSetters{outputFile} = \&setOutputFile;
$_allMemberAttributes{tmpDir} = {
          'name' => 'tmpDir',
          'default' => '.',
          'description' => 'The temp dir to use for transformations'
        }
;
$_allSetters{tmpDir} = \&setTmpDir;
$_allMemberAttributes{commands} = {
          'ref' => 'ARRAY',
          'name' => 'commands',
          'description' => 'The commands that the file should be processed with. It is internally derived unless specified'
        }
;
$_allSetters{commands} = \&setCommands;
$_allMemberAttributes{directive} = {
          'name' => 'directive',
          'default' => 'xfmpipe',
          'description' => 'It is not a true syntax engine, but you can override the directive label in the file'
        }
;
$_allSetters{directive} = \&setDirective;
$_allMemberAttributes{fileExtensionMapDB} = {
          'name' => 'fileExtensionMapDB',
          'default' => '$ENV{XFMPIPE_FILEEXTENSIONS}',
          'description' => 'Get a list of canned conversions that should be run on different file formats. Determine the conversion based on the extension. The file should have a HASH named $data that has the extensions in the key and the \\%commands in the value.'
        }
;
$_allSetters{fileExtensionMapDB} = \&setFileExtensionMapDB;
$_allMemberAttributes{keep} = {
          'name' => 'keep',
          'default' => 0,
          'description' => 'Keep the intermediate files'
        }
;
$_allSetters{keep} = \&setKeep;
$_allMemberAttributes{_currentIterator} = {
          'name' => '_currentIterator',
          'default' => 1,
          'description' => 'Internal member for tracking the current conversion operation'
        }
;
$_allSetters{_currentIterator} = \&set_currentIterator;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


#
# The "reflectionAPI" builds a hash of %_allMemberAttributes recursively. In other words,
# get a hash that lists everything that this class and parents can do. It is like "UNIVERSAL::can" 
# only, it returns explicitly everything available in the "->" callstack.
#
sub getReflectionAPI { 
    my $this = shift;
    my %tmp = ();
    eval { %tmp = $this->SUPER::getReflectionAPI() }; # recursively call it to get all members
    return (%tmp, %_allMemberAttributes);
}

#
# Constructor
#
# Note - this cannot be used as a cloner. It will inherit all the default params of all parent classes.
#
sub new {
    my $caller = shift;
    my $class = ref $caller;

    Confess "Missing the value for an argument (even nulls) on creation of Directive" if scalar @_ % 2 != 0;

    my %args = @_;

    #
    # If a class was handed (from a subclass) then it takes precendent
    #    
    my $this = $class ? $caller : bless {}, $caller;

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object Directive. typo ?\n";
        }
    }


    $this->{tmpDir} = "." unless defined $this->{tmpDir};

    $this->{directive} = "xfmpipe" unless defined $this->{directive};

    $this->{fileExtensionMapDB} = $ENV{XFMPIPE_FILEEXTENSIONS} unless defined $this->{fileExtensionMapDB};

    $this->{_currentIterator} = "1" unless defined $this->{_currentIterator};


    eval {
	$this->__new(%args) if $this->UNIVERSAL::can("__new");
    };
    croak $@ if $@;

    #
    # I am not sure what the reasoning here is... I am guessing that we are trying to call up the
    # stack and give each parent object the chance to initialize in some way. I think that happens,
    # but also, the _new and __new fns are called 2 times, and since super works on packages, not
    # references, it might get lost from time to time. TODO - figure out the code impact to changing this
    #
    eval {
	$this->SUPER::new(%args);
    };
    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    eval {
	$this->_new(%args) if $this->UNIVERSAL::can("_new");
    };
    croak $@ if $@;

    return $this;
}

=pod

=head1 MEMBER ACCESS METHODOLOGY

All members support Java-style
setters and getters. The ending parens on the getters (or perl universals) are optional. That
is, if you aren't passing a variable to the setter/getter, then you can optionally drop the 
parens.

=head2 Java Style

The member variable will be first-letter upper cased and have 'get' or 'set' prepended to it.
It would be referenced as follows for a member named dbh:

  $obj->setDbh( 'someValue' );
  $obj->getDbh;

=head1 MEMBERS

=cut



=pod

=head2 inputFile => "any string"

The input file that should be processed

=cut

sub getInputFile {
    my $this = shift;

    return $this->{inputFile};
}
sub setInputFile {
    my $this = shift;

    my $inputFile = shift;
    $this->{inputFile} = $inputFile;
    return $inputFile;
}


=pod

=head2 outputFile => "any string"

The output file that should be created

=cut

sub getOutputFile {
    my $this = shift;

    return $this->{outputFile};
}
sub setOutputFile {
    my $this = shift;

    my $outputFile = shift;
    $this->{outputFile} = $outputFile;
    return $outputFile;
}


=pod

=head2 tmpDir => "any string" [DEFAULT: '"."']

The temp dir to use for transformations

=cut

sub getTmpDir {
    my $this = shift;

    return $this->{tmpDir};
}
sub setTmpDir {
    my $this = shift;

    my $tmpDir = shift;
    $this->{tmpDir} = $tmpDir;
    return $tmpDir;
}


=pod

=head2 commands => ARRAY

The commands that the file should be processed with. It is internally derived unless specified

=cut

sub getCommands {
    my $this = shift;

    return $this->{commands};
}
sub setCommands {
    my $this = shift;

    my $commands = shift;
        if (defined $commands) { Confess "argument 'commands' of method Directive->setCommands() is required to be of reference type ARRAY " unless ref($commands) =~ /^ARRAY/;}
    $this->{commands} = $commands;
    return $commands;
}


=pod

=head2 directive => "any string" [DEFAULT: '"xfmpipe"']

It is not a true syntax engine, but you can override the directive label in the file

=cut

sub getDirective {
    my $this = shift;

    return $this->{directive};
}
sub setDirective {
    my $this = shift;

    my $directive = shift;
    $this->{directive} = $directive;
    return $directive;
}


=pod

=head2 fileExtensionMapDB => "any string" [DEFAULT: '$ENV{XFMPIPE_FILEEXTENSIONS}']

Get a list of canned conversions that should be run on different file formats. Determine the conversion based on the extension. The file should have a HASH named $data that has the extensions in the key and the \%commands in the value.

=cut

sub getFileExtensionMapDB {
    my $this = shift;

    return $this->{fileExtensionMapDB};
}
sub setFileExtensionMapDB {
    my $this = shift;

    my $fileExtensionMapDB = shift;
    $this->{fileExtensionMapDB} = $fileExtensionMapDB;
    return $fileExtensionMapDB;
}


=pod

=head2 keep => "any string"

Keep the intermediate files

=cut

sub getKeep {
    my $this = shift;

    return $this->{keep};
}
sub setKeep {
    my $this = shift;

    my $keep = shift;
    $this->{keep} = $keep;
    return $keep;
}


=pod

=head2 _currentIterator => "any string" [DEFAULT: '"1"']

Internal member for tracking the current conversion operation

=cut

sub get_currentIterator {
    my $this = shift;

    return $this->{_currentIterator};
}
sub set_currentIterator {
    my $this = shift;

    my $_currentIterator = shift;
    $this->{_currentIterator} = $_currentIterator;
    return $_currentIterator;
}


=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {
    my $this = shift;

    return $this->{debug};
}
sub setDebug {
    my $this = shift;

    my $debug = shift;
    $this->{debug} = $debug;
    return $debug;
}


=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless defined $this->{$_};
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

1;

=pod

=head1 OBJECT METHODS

=cut



sub _new {

=pod

=head3 $Directive->_new ()


callback constructor, do not call directly use new() instead

=cut
    my $this = shift;
    confess ref($this) . "->_new requires named arguments" if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;

}


sub docmd (@) {    
    
=pod

=head3 $Directive->docmd ()


Run a command against the shell and exit if the return code is non-zero

=cut
    my $this = shift;


    $this->debugPrint(1, @_);
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}


sub process {
    
=pod

=head3 $Directive->process ()


generate the output

=cut
    my $this = shift;
    confess ref($this) . "->process requires named arguments" if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;

    do {

        #
        # tmp dir takes the process id to make it really temp.
        $this->setTmpDir( $this->getTmpDir . "/.directive.$PROCESS_ID" );
        $this->docmd( 'mkdir -p ' . $this->getTmpDir );
	
        #
        # Get the list of commands to run
        $this->deriveCommands();

        #
        # do the processing
        for my $cmd ( @{ $this->getCommands } ) {
            $this->applyConversion( command => $cmd );
        }
        $this->copyToOutput();

        #
        # delete the temp dir (and delete everything)
        #
        if ($this->getKeep) {
            $this->debugPrint( 1, "Itermediate files left in " . $this->getTmpDir );
        } else {
            $this->docmd( 'rm -rf ' . $this->getTmpDir );
        }
    };
}    

sub deriveCommands {
    
=pod

=head3 $Directive->deriveCommands ()


parse the input file (maybe) to derive the commands that should run

=cut
    my $this = shift;
    confess ref($this) . "->deriveCommands requires named arguments" if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;

    do {
        return if $this->getCommands;

        my $d = $this->getDirective();
        open(F, '<' . $this->getInputFile) || Confess "Can't open file: " . $this->getInputFile . ": $!";
        while (<F>) {

            #
            # take the top one only.
            # 
            if (m/(\$$d\s*=\s*\[.+?\])/) {
                no strict;
                local $x;
                eval "\$x = $1";
                $this->setCommands( $x );
                last;
            }
        }
        close(F);
        $this->deriveFileExtensionBasedCommand() unless $this->getCommands;
        $this->setCommands( [{ command => 'cat' }] ) unless $this->getCommands; # default is to cat
    };
}

sub applyConversion {
    
=pod

=head3 $Directive->applyConversion (command => 'any string')

 - command ('any string')		 : The command that should get applied

given a command, take the current inputfile through that command

=cut
    my $this = shift;
    confess ref($this) . "->applyConversion requires named arguments" if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $command = $args{command};

    do {
        # create a new input file
        my $output = $this->getTmpDir . '/directive.iter.' . $this->get_currentIterator;
        my $input = $this->getInputFile();

        # backwards compatibility
        my $cmd = $command->{command};
        my $doExec = $command->{exec};
        my $doCat = $command->{cat};
        my $doChmod = $command->{chmod};

        # pick up things from the environment
        $cmd .= ' --debug' if $this->getDebug;

        # run the command
        if ($cmd =~ /^cat/) {
            $this->docmd( "$cmd $input > $output" );
        } else {
            $this->docmd( "$cmd < $input > $output" );
        }
        $this->docmd( "chmod $doChmod $output" ) if $doChmod;
        $this->docmd( "cat $output" ) if $doCat;

        $this->docmd( "$ENV{SHELL} $output" ) if $doExec;
        
        $this->setInputFile( $output );
        $this->set_currentIterator( $this->get_currentIterator + 1 );
    };
}


sub copyToOutput {
    
=pod

=head3 $Directive->copyToOutput ()


Create the final output file.

=cut
    my $this = shift;
    confess ref($this) . "->copyToOutput requires named arguments" if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;

    do {
        $this->docmd( 'cp ' . $this->getInputFile . ' ' . $this->getOutputFile );
    };
}

sub deriveFileExtensionBasedCommand {
    
=pod

=head3 $Directive->deriveFileExtensionBasedCommand ()


Look up the conversion command string based on the filename extension. This offers another way to list what can be done.

=cut
    my $this = shift;
    confess ref($this) . "->deriveFileExtensionBasedCommand requires named arguments" if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;

    do {
        return unless $this->getFileExtensionMapDB;
        my $extension = $this->getInputFile;
        $extension =~ s/^.+\.([^\.]+)(\.xfm|)$/$1$2/;
        $this->debugPrint( 1, "Attempting to derive the file extension from $extension" );
        eval {
            no strict;
            local $data;
            require $this->getFileExtensionMapDB;
            if ( exists $data->{$extension} ) {
                $this->setCommands( $data->{$extension} );
            }
        }; if ($@) {
            Confess "Bad file extension map " . $this->getFileExtensionMapDB . ": $@";
        }
    };
}
