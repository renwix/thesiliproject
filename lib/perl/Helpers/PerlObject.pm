# gpl
# 
#  Author: Renwix (renwix@gmail.com)
#  Maintainer: Renwix
#  Copyright (C) 2008 Renwix, all rights reserved.
#  Created: Tue Sep 23 23:52:17 MDT 2008
# 
# 
#=======================================================================
# 
# This file is part of theSiliProject, a humorous software organization,
# design and development toolkit.
# 
# theSiliProject is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# theSiliProject is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with theSiliProject. If not, see <http://www.gnu.org/licenses/>.
# 
#=======================================================================
# 
# /gpl

#
# There are 2 types of code in this file :
# 1) Code that generates code
# 2) Code that determines what code should be generated - true object code
#
# The functions are all classified as such
# 

package Helpers::PerlObject;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use Helpers::shell;

sub Confess {confess BOLD, RED, @_, RESET}
sub CONFESS { Confess( @_) }

#
# _scalarOrCode()   : internal Fn
#
# used during the GetOpts 'default' expansion. If the default looks like code
# then it will just return it, if not, then it will quote it.
# 
sub _scalarOrCode {
    my $arg = shift;
    if ($arg !~ /(^new\s|::|&|\(.*\)|\$|\@|\%|^\[|^\{)/) {    # try to guess if it is a scalar or not
        return '"' . $arg . '"';                      # if it is scalar, then quote it.
    }
    return $arg;
}

#
# newObject()  : generatesCode
#
# produces a class file header that contains compilation information and pod documentation
# 

sub newObject
{
    my $this = shift;
    my %args = @_;
    my $ret;

    Confess "No Object description: use description argument" unless $this->{description};

    $whoami = `whoami`;
    chomp($whoami);
    $hostname = `hostname`;
    chomp($hostname);
    $uname = `uname -a`;
    chomp($uname);


    $ret .= "

=pod

=head1 NAME - $this->{name}

$this->{description}

=head1 EXAMPLE

" . ($this->{example} ? $this->{example} : "No example(s) have been documented for this object.") . "


=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated by $whoami on $hostname ($uname)

=cut


# This file was automatically generated by $whoami on $hostname ($uname)
# DO NOT EDIT THIS FILE 


package $this->{name};

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use UNIVERSAL qw(isa can);
use strict;
our (\@ISA, \@EXPORT);
sub Confess (\@) {confess BOLD, RED, \@_, RESET}
sub CONFESS (\@) { Confess(\@_) }
sub Croak (\@) {croak BOLD, RED, \@_, RESET}

";

    $ret .= Helpers::shell::printmsg();
    $ret .= Helpers::shell::docmd();
    $ret .= Helpers::shell::docmdi();

    map {
        $ret .= "use $_;\n";
    } @{ $this->{include} };

    if ($this->{isa}) {
        $ret .= "

push \@ISA, qw($this->{isa});

=pod

=head1 INHERITANCE

$this->{name} extends class(es) $this->{isa} ; refer to the documentation for that object for member variables and methods.

=cut

";
    }

    unless ($this->{noUseIsa}) {
        for (split /(\s+|,)/, $this->{isa}) {
            $ret .= "use $_;\n";
        }
    }


# fields will go in the constructor now...
#     $ret .= "use fields qw(";

#     my $members = $this->{members};

#     if ($members) {
# 	map {
#             $ret .= " $_->{name}";
# 	} (@{$members});
#     }
#     $ret .= " );";

    $ret .= "{\n\tmy \$_class_attrs = {\n";

    my $members = $this->{members};

    if ($members) {
	map {
            $ret .= "\t\t$_->{name} => undef,\n";
	} (@{$members});
    }
    $ret .= "\t};\n\tsub _class_attrs { $_class_attrs }\n}";
    return $ret;
}

#
# constructor(%args)  : generatesCode
#
# produces a constructor for the class that is being defined. The constructor is called 'new'.
# It does the following processing in order:
#
#  - argument processing
#  - __new()
#  - $this->SUPER::new()
#  - _new()
#
# Argument processing is done with the setter that corresponds to each field name.
#
# That requires more detail:
# The generated class contains 2 hashes named %_allSetters and %_allMembers. These hashes
# have the same keys, but the setters hash contains pointers to the setter function for a
# particular key. The members hash just contains a true value.
#
# A user can get at this class meta information by referencing it explicitly :
#  --     my $class_fields = keys %{ *{ "$class::_allSetters" } }
#
# The constructor is also going to check that there are not arguments that fall outside
# the range of fields. If it finds one of these, it will error.
# 

sub constructor
{
    my $this = shift;
    my %args = @_;
    my $ret;

    $ret .= "

=pod

=head1 CONSTRUCTOR

=over 4

=item $this->{name}" . '->'."new()

initializes on object of type $this->{name}

=back

=cut

";

    #
# generate a lookup table for all valid member variables
#

    $ret .= '
#
# _allMemberAttributes | _allSetters
#
# This class is generated from PerlObject which is a declaration of
# everything that makes up a class. That is - it gives declaritive
# syntax for all object members, docs, defaults etc. That information
# gets cached with each class for interrogation via a "reflectionAPI".
# That API relies on these static structures.
# 

my %_allSetters = ();
my %_allMemberAttributes = ();
';
    my $members = $this->{members};

    if ($members) {
	map {
            my $reflection = Data::Dumper->new([$_]);
            $reflection->Purity(1)->Terse(1)->Deepcopy(1);
            $ret .= '$_allMemberAttributes{' . $_->{name} . "} = " . $reflection->Dump() . ";\n";
	    $ret .= '$_allSetters{' . $_->{name} . "} = \\\&set" . ucFirstChar($_->{name})  . ";\n";  
	} (@{$members});

    }

    $ret .= '

#
# The "reflectionAPI" builds a hash of %_allMemberAttributes recursively. In other words,
# get a hash that lists everything that this class and parents can do. It is like "UNIVERSAL::can" 
# only, it returns explicitly everything available in the "->" callstack.
#
sub getReflectionAPI { 
    my $this = shift;
    my %tmp = ();
    eval { %tmp = $this->SUPER::getReflectionAPI() }; # recursively call it to get all members
    return (%tmp, %_allMemberAttributes);
}

#
# Constructor
#
# Note - this cannot be used as a cloner. It will inherit all the default params of all parent classes.
#
sub new {
    my $caller = shift;
    my $class = ref $caller;

    Confess "Missing the value for an argument (even nulls) on creation of ' . $this->{name} . '" if scalar @_ % 2 != 0;

    my %args = @_;

    #
    # If a class was handed (from a subclass) then it takes precendent
    #    
    my $this = $class ? $caller : bless {}, $caller;

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object ' . $this->{name} . '. typo ?\n";
        }
    }

';
    $ret .= '    $this->trace( ref($this) );' . "\n" if $this->{traceOn};

#
# After the boilerplate constructor is layed down, we need to monkey the
# default values.
# 
  if ($members) {
	map {

            if ($_->{default}) {
                my $default = _scalarOrCode( $_->{default} );
                $ret .= "
    \$this->{$_->{name}} = $default unless defined \$this->{$_->{name}};
";
            }

            $ret .= "
    Confess \"cannot initialize object of type $this->{name} without required member variable $_->{name}\"
        unless exists \$this->{$_->{name}};
" if $_->{required};

	} (@{$members});
    }


# CallOrder:
#
# $this->__new()
# SUPER->new()
# $this->_new();
#

$ret .= '

    eval {
	$this->__new(%args) if $this->UNIVERSAL::can("__new");
    };
    croak $@ if $@;

    #
    # I am not sure what the reasoning here is... I am guessing that we are trying to call up the
    # stack and give each parent object the chance to initialize in some way. I think that happens,
    # but also, the _new and __new fns are called 2 times, and since super works on packages, not
    # references, it might get lost from time to time. TODO - figure out the code impact to changing this
    #
    eval {
	$this->SUPER::new(%args);
    };
    croak $@ if $@
	and $@ !~ /^Can\\\'t locate object method/;

    eval {
	$this->_new(%args) if $this->UNIVERSAL::can("_new");
    };
    croak $@ if $@;

    return $this;
}
';

    return $ret;
}


#
# new() : thisObjectConstructor
#
# This is used to return a PerlObject object. A PerlObject has the following fields
# (and the new function supports the following arguments):
#
# - name : documentation
# - description : documentation
# - example : documenation
# - where : documentation - defaults to the p4 path to the file if 'file' is specified in the arg list.
# - include : A list of .pm files that should be 'used'
# - isa : A list of classes for the @ISA array
# - traceOn : turn on tracing of the class
# - noConstructor : Boolean - if specified, the 'constructor()' fn isn't called
# - members : ARRAY - the fields in this object. Will be used to generate setters/getters
# - interface : ARRAY - the interface that this object should require. Creates Virtual Fn for each fn defined.
# - callbacks : ? - doesn't look like it is implemented
#
# The following structures are defined in this object - implicitly:
#
# The "GetOpts" Structure (an array that contains a hash for each option):
#    - name : REQUIRED; the name of the option - this might be a command line arg, or it might be a member name
#    - description : REQUIRED; a description of the option - for docs and whatnot
#    - default : OPTIONAL; if provided, the default value will be used unless another value is in the arg list.
#    - required : OPTIONAL; boolean - if true, the option is required by the fn
#    - noThis   : OPTIONAL; if specifed, then the $this var isn't set to shift;
#    - objectAgnostic   : OPTIONAL; if specifed, then the the $this var is inspected to see if it was an object or not.
#                         This facilitates fn calls in both OO and non-OO syntax.
#    - message  : OPTIONAL; the message that is returned if the object fails the 'ref' test. The default message
#                 includes info related to ->isa() and is non-intuitive for a non Perl person. Use this field
#                 to change the message to something more relevant. Quoting Trick: Use ' to define the message
#                 in the getopts hash. The expansion will be based on ", so you can do variable expansion in your message if you
#                 get the quoting right.
#    - ref : OPTIONAL; The type of an argument. Defaults to ref eq '' or string
#    - format : OPTIONAL; This is superceeded by ref. If ref is specified - this field will be ignored!
#               A regexp that will be used in the contract to determine if the argument value is acceptable
#    - positionalParameters : OPTIONAL; The arguments passed to a generated function are in a hash by default.
#                             This allows for named arguments. If you want to override this, then specify
#                             this field as part of the getOpts call.
#
# The "Members" Structure:
#    - Exactly the same as the GetOpts structure. The name of the option is the name of the member.
#
# The "Methods" Structure (internal hash containing the name of the member pointing at a hash that contains):
#    - description : REQUIRED; a description of the method
#    - positionalParameters : OPTIONAL; see the getopts structure
#    - getopts : OPTIONAL; array - all collection of ordered GetOpts structures
#
#


sub new {
    my ($class, %args) = @_;
    $args{_obj} = {};
    my $name = ref($class) || $class;
    $args{_TYPE_} = $name;

    bless \%args, $name;

    my $obj = \%args;
    $obj->setMethods("_new" => {description => "callback constructor, do not call directly use new() instead"});

    $args{file} =~ s/\n//g;
    if (defined $args{file}) {
        my $where = `p4 where $args{file}`;
        $where =~ s/(.+?)\s.*/$1/;
        chomp($where);
        $args{where} = $where;
    }

    return \%args;
}


#
# finish()   : generateCode
#
# prints the footer on the class file
# 

sub finish {
    return "
1;

=pod

=head1 OBJECT METHODS

=cut

";
}


#
# setMembers()    : thisObjectCode
#
# Use this function to specify the properties of the members in this file. The syntax is like:
#
#  $po->setMembers( [ GetOpt Struct, ... ] )
#

sub setMembers {
    my $this = shift;
    
    $this->{members} = shift;

    my $found = 0;
    my @additional = ( { name => debug, description => 'debug allows an object to specify its debugPrint level' },
#                       { name => trace, description => 'A flag indicating whether trace should be turned on' },
                       );

    if ($ENV{TRACE}) {
        $this->{traceOn} = 1;
    }

    for my $add (@additional) {
        for my $m (@{ $this->{members} } ) {
            if ($m->{name} eq $add->{name}) {
                $found++;
            }
        }
        unless ($found) {
            push @{$this->{members}}, $add;
        }
    }

}


#
# setInterface()    : thisObjectCode
#
# Use this function to specify the interface of this class. The syntax is like:
#
#  $po->setInterface( [ { name => 'methodName', description => 'method description' }, ... ] )
#
sub setInterface {
    my $this = shift;
    
    $this->{interface} = shift;
}



#
# ucFirstChar()    : internal Fn
#
# This is used to standardize the names of the setters and getters. That is the name
# should always be 'set' . ucFirstChar($_[0]) or 'get' . ucFirstChar($_[0])
# 
sub ucFirstChar {
    my $val = shift;

    return uc(substr($val,0,1)) . substr ($val,1);
}


#
# generateSettersAndGetters()   : generateCode
#
# Loop through all the $this->{members}, create $this->{methods} for the setters and getters
# and then dumpContract on all of those definitions. This has the effect of printing out all
# the code necessary for specifying setters and getters.
# 
sub generateSettersAndGetters {
    my $this = shift;
    my $member = shift;
    my $ret = "";

    my $name = $member->{name};
    my $functionName = ucFirstChar($member->{name});

    my $memberType = ( $member->{ref} ? $member->{ref} : ($member->{format} ?
							      "\"$member->{format}\"" : "\"any string\""));
    my $memberStr .= $member->{name} . " => " . $memberType
	. ($member->{required} ? "*" : "");

    if ($member->{default}) {
        my $default = _scalarOrCode( $member->{default} );
        $memberStr .= " [DEFAULT: '$default']";
    }
	$ret .= "

=pod

=head2 $memberStr

$member->{description}

=cut

";

    delete $member->{default};

    $this->setMethods ("get" . $functionName => { description => "getter for member $member->{name}",
                                                  skipPerlDocs => 1,
						  positionalParameters => "T",},
		       "set" . $functionName => { description => "setter for member $member->{name}",
						  positionalParameters => "T",
                                                  skipPerlDocs => 1,
						  getopts => [$member],},
                       $member->{name} => { description => "Universal setter/getter for member $member->{name}",
                                            positionalParameters => "T",
                                            skipPerlDocs => 1,
                                            getopts => [$member],});


    $ret .= "sub get$functionName {\n" . $this->dumpContract(method => "get" . $functionName) . "    return \$this->{$name};\n}\n";
    # I've made a change where the passed in value is returned by the setter - this allows you to do things like
    # "return $this->setSomething(something);" in other functions.
    $ret .= "sub set$functionName {\n" . $this->dumpContract(method => "set" . $functionName) . "    \$this->{$name} = \$$name;\n    return \$$name;\n}\n";
    #
    # And Perl doesn't usually use setters/getters... Rather, a universal fn that can both set and get. This is
    # more closely aligned with OO "properties". It isn't true because perl uses LVALUES in a limited way, but this
    # gets pretty close.
    # CURRENTLY WON'T WORK DUE TO NAMING CONFLICTS
    # 
#    $ret .= "sub $member->{name} {\n" . $this->dumpContract(method => $member->{name}) . "    \$this->{$name} = \$$name;\n    return \$$name;\n}\n";
    
    return $ret;
}


#
# generateMembers()   : generateCode
#
# For each member that is defined, generate documentation associated with it and
# then call into generateSettersAndGetters for that member.
# 
sub generateMembers {
    my $this = shift;
    my $members = $this->{members};
    my $ret = "";

#  2 styles of access methods, Perl Universal setters/getters and 
# =head2 Perl Style 

# The perl style will be named EXACTLY for your member variable. So if you have a member named dbh
# you can reference it with:
 
#   \$obj->dbh( 'SomeValue' );
#   return \$obj->dbh;

    $ret .= "
=pod

=head1 MEMBER ACCESS METHODOLOGY

All members support Java-style
setters and getters. The ending parens on the getters (or perl universals) are optional. That
is, if you aren't passing a variable to the setter/getter, then you can optionally drop the 
parens.

=head2 Java Style

The member variable will be first-letter upper cased and have 'get' or 'set' prepended to it.
It would be referenced as follows for a member named dbh:

  \$obj->setDbh( 'someValue' );
  \$obj->getDbh;

=head1 MEMBERS

=cut

";

    map {
	Confess "no description found for variable $_->{name} of object $this->{name}" unless $_->{description};
	$ret .= $this->generateSettersAndGetters($_);

    } (@{$members});


    return $ret;
}


#
# dumpStandardSetters()   : generateCode
#
# The generate object will have a handful of functions that are generated for free.
# These functions are:
#   - _require
#   - ...
#
# This function handles that work. It is called during the dump phase
# 
sub dumpStandardSetters {
    my $ret = "";
    $ret .= '

=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless defined $this->{$_};
    } (@_);
}

';



    return $ret;

}


#
# setMethods()  : internal Fn, thisObjectCode
#
# Use of this function is deprecated in favor of 'contract'. It used to be that a user would
# call this during the definition of their object. They would then reference the methods by
# name later during a 'dumpContract' call. That functionality is exactly replaced with 'contract'.
#
# There are a handful of classes that still use this function, so it lives on... but shouldn't.
# 
sub setMethods {
    my $this = shift;
    my %args = @_;

    foreach my $key (keys(%args)) {
	$this->{methods}->{$key} = $args{$key};
    }
}


#
# contract()   : thisObjectCode
#
# A contract is a concept. It doesn't exist in this detail in a lot of coding systems, but
# it is the notion that the arguments that are passed into a function should be checked
# for things like type (which is the case with most typing languages) but also for additional
# items that are user defined. It might include regexp matches against the values, or format
# checking.
#
# The 'contract' support in PerlObjects is built with 2 main calls:  'contract' defines the
# contract data and 'dumpContract' expands that contract data into working perl code.
#
# This takes a Method Structure as an argument (unnamed).
#   -   contract( methodName => { description => ' ... ', ... } )
#   
sub contract {
    my $this=shift;                              # get the current object
    $this->setMethods(@_);
    return $this->dumpContract(method => shift);
}


#
# mixin()    : thisObjectCode
#
# This is a mixin that is defined as a contract. It is basically the same thing, it just
# works in both OO and non-OO syntax.
# 
sub mixin {
    my $this = shift;
    my ($methodName, $rhsh) = @_;
    $rhsh->{objectAgnostic} = 1;
    $this->setMethods( $methodName => $rhsh );

    #
    # use embedperl trailing file descriptors to merge mixin information to the end of the
    # generated file. Essentially the following information gets appended to the end
    # of all expansion work. Thanks Jeremy and Java Class generation!
    # 
    unless (exists $this->{usingMixins}) {
        $this->{usingMixins} = 1;
        @Expander::_trailing_fd[0] = "use Exporter;\npush \@ISA, qw( Exporter );\n" unless $this->{isa} =~ /Exporter/;
        @Expander::_trailing_fd[1] = "push \@EXPORT, qw( ";
        @Expander::_trailing_fd[3] = ");\n\n" . _mixins();
    }
    @Expander::_trailing_fd[2] .= "$methodName ";
    

    my $o = $this->dumpContract( method => $methodName );

    #
    # this allows the fn to work as both an OO method and a regular fn
    # 
#    $o .= '    %args = ( $this, @_ ) if defined $this && ! _is_object( $this );' . "\n";

    return $o;
}

sub _mixins {
    my $o =<<'EOF';

=pod

=head2 _is_object

Syntax:

    boolean = _is_object( $object );

Internal function to wrap up the test if a thing is an object or not. If this returns true, then things like 'can' and 'isa' can be
executed against this object.

=cut
sub _is_object {
    my ($obj) = @_;
    $_ = ref $obj;

    return 0 unless $_;
    return 0 if /^(SCALAR|ARRAY|HASH|CODE|REF|GLOB|LVALUE)$/;
    return 1;    
}
EOF
    return $o;
}


#
# dumpContract()   : generateCode
#
# Given a methodName it looks up the contract data for that method and then dumps the perl
# code that implements that contract.
# 
sub dumpContract {
    my $this = shift;
    my %args = @_;
    my $ret ;

    my $method = $args{method};

    $methodObject = $this->{methods}->{$method};

    Confess "no contract defined for method $method of $this->{name}" unless $methodObject;

    my $description = $methodObject->{description};

    # positionalParameters means parameters are in order, not a hash.
    my $positionalParameters = $methodObject->{positionalParameters};
    my $noThis = $methodObject->{noThis} || 0;
    my $objectAgnostic = $methodObject->{objectAgnostic} || 0;
    
    Confess "no description set for method $method of object $this->{name}" unless $description;

    my $optionStr = "(";                      # representation of arguments for pod docs
    my $getopts = $methodObject->{getopts};   # get the options structure
    my $numOptions = 0;                       # count the number of options
    my $optionDescrString;                    # a string used to describe each option on a new line
    my $optionValidationString;               # code for option validation.


    # I'd like this but the "my" variable is a problem.
#    $optionValidationString .= "    eval { \n";
    
    foreach my $option (@{$getopts}) {
	Confess "you attempted to define an option without defining a name for it (use name => parameter).  Object is \n" . Dumper($option)
	    unless ($option->{name});

	$optionStr .= ", " if $numOptions++;
	my $optionType = ( $option->{ref} ? $option->{ref} : ($option->{format} ?
							      "\"$option->{format}\"" : "'any string'"));
	$optionStr .= ($option->{required} ? "* " : "") . $option->{name} . " => " . $optionType;
	Confess "no description set for all arguments to  method $method of object $this->{name}" unless $option->{description};
	my $tab = ((length($option->{name} > 8) ? "\t" : "\t\t"));
	$optionDescrString .= "\n - $option->{name} ($optionType)$tab : $option->{description}";


        if ($option->{default}) {
            
            my $default = _scalarOrCode( $option->{default} );
            $optionDescrString .= " [DEFAULT: '$default']";

            if ($positionalParameters) {
            
                $optionValidationString .= "    my \$$option->{name} = (scalar \@_ ? shift : $default);\n";
            } else {

                $optionValidationString .= "    my \$$option->{name} = (\$args{$option->{name}} ? \$args{$option->{name}} : $default);\n";
            }
        } else {

            if ($positionalParameters) {

                $optionValidationString .= "    my \$$option->{name} = shift;\n";

            } else {

                $optionValidationString .= "    my \$$option->{name} = \$args{$option->{name}};\n";
            }
        }



	if ($option->{required}) {
	    $optionValidationString .= "    Confess \"argument '$option->{name}' is required for $this->{name}"."->$method"."()\" " .
		($positionalParameters 
		 ? "unless defined \$$option->{name};\n"
		 : "unless exists \$args{$option->{name}};\n");
	}
	if ($option->{ref} =~ /^REF/ or
	    $option->{ref} =~ /^CODE/ or
	    $option->{ref} =~ /^SCALAR/ or
	    $option->{ref} =~ /^HASH/ or
	    $option->{ref} =~ /^ARRAY/) {
	    $optionValidationString .= "        if (defined \$$option->{name}) { Confess \"argument '$option->{name}' of method $this->{name}"."->$method"."() is required to be of reference type $option->{ref} \" unless ref(\$$option->{name}) =~ /^$option->{ref}\/;}\n";	    
	} elsif ($option->{ref}) {
	    $optionValidationString .= "    eval {my \$dummy = \$$option->{name}"."->isa(\"$option->{ref}\");};" . 'Confess "' . ($option->{message} ? $option->{message} : '$@') . '\n" . Dumper(' . "\$$option->{name}" . ') if $@;' . "\n"; 
	    $optionValidationString .= "    if (defined \$$option->{name}) { Confess \"argument '$option->{name}' of method $this->{name}"."->$method"."() is required to be of reference type $option->{ref} \" unless \$$option->{name}"."->isa(\"$option->{ref}\");}\n";
	} elsif ($option->{format}) {
	    $optionValidationString .= "        if (defined \$$option->{name}) { Confess \"argument '$option->{name}' of method $this->{name}"."->$method"."() failed format validation of \'" . $option->{format} . "\'\" unless \$$option->{name} =~ /$option->{format}\/;}\n";
	}
	

    }
    $optionStr.=")";

#    $optionValidationString .= '
#    };
#    Confess "$@" if $@;
# ';                                                                             
    
    my $shortName = $this->{name};
    $shortName =~ s/(.+?::)?(.+?)/$2/;

    unless ($methodObject->{skipPerlDocs}) {
    $ret .= "
=pod

=head3 \$$shortName"."->$method $optionStr
$optionDescrString

$description

=cut
";
    }

    my $argumentProcessor = ''; # =         #code to pull out arguments from the function call (@_)
    if ($noThis) {
        $argumentProcessor .= "    my \$this = undef;\n";
    } elsif ($positionalParameters) {
        $argumentProcessor .= "    my \$this = shift;\n";
    } elsif ($objectAgnostic) {
        $argumentProcessor .= '    my $this = shift;
    unshift @_, $this unless _is_object( $this );
    confess ref($this) . "->' . $method . ' requires named arguments" if scalar @_ && scalar @_ % 2 != 0;
';
        
    } else {
        $argumentProcessor .= '    my $this = shift;
    confess ref($this) . "->' . $method . ' requires named arguments" if scalar @_ && scalar @_ % 2 != 0;
';
    }
    $argumentProcessor .= '    my %args = @_;';

    $ret .= '    $this->trace( ref($this) );' . "\n" if $this->{traceOn};
    $ret .= $argumentProcessor . "\n" . $optionValidationString;

    

# #####
#     if ($positionalParameters) {
#         $argumentProcessor = '    my $this = shift;
# ';
#     } elsif ( ! $noThis ) {
#         $argumentProcessor .= '    my $this = shift;
#     confess ref($this) . "->' . $method . ' requires named arguments" if scalar @_ && scalar @_ % 2 != 0;
# ';
#     }
    
#     if ( $noThis ) {
#         $argumentProcessor .= " my \$this = undef;\n";
#     }
        
#     $argumentProcessor .= 'my %args = @_;';

#     $ret .= '    $this->trace( ref($this) );' . "\n" if $this->{traceOn};
#     $ret .= $argumentProcessor . "\n" . $optionValidationString;
# ######
    return $ret;
}


#
# virtualMethod()   : generateCode
#
# Given the name of a virutal method (from the interface data) - generates a virtual
# method implementation
# 
sub virtualMethod {
    my $this = shift;
    my $method = shift;
    my $ret = "";

    return unless $method->{name};
    my $name = $method->{name};
    $ret .= "

=pod

=head2 $name

$method->{description}

=cut

";

    $ret .= "sub $name { croak 'Virtual method $name called. This should be implemented in a child class.' }\n";
    return $ret;
}


#
# generateInterface()   : generateCode
#
# Loops through all the interface definitions and calls virtualMethod() on the method.
# 
sub generateInterface {
    my $this = shift;
    my $interfaces = $this->{interface};
    my $ret = "";
    my $data = "";

    $ret .= "
=pod

=head1 VIRTUAL METHODS

=cut

";

    map {
	Confess "no description found for variable $_->{name} of object $this->{name}" unless $_->{description};
	$data .= $this->virtualMethod($_);

    } (@{$interfaces});


    return $ret . $data if $data;
}



#
# debugPrint()   : generateCode
#
# Prints the debugPrint function into the code. This could potentially be in the 'dumpStandardSetters'
# code line.
# 
sub debugPrint () {
    my $o =<<'EOF';
sub debugPrint { 
    my $this = shift;
    my $level = shift;
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}
EOF

}



#
# trace()   : generateCode
#
# Prints the trace function into the class. This is only printed if the $this->{traceOn}
# field is specified, or the $TRACE environment variable is set.
#
sub trace () {
    my $o =<<'EOF';
sub trace { 
    my $this = shift;
    if ($ENV{TRACE}) {
        my ($caller) = (caller(1))[3];
        if ($ENV{TRACE} =~ /^(t|true|y|yes|1)/i) {            # no-op

        } elsif ($ENV{TRACE} =~ /^(f|false|n|no|0)/i) {       # no tracing
            return 0;
        } else {                                            # assume regexp
            return unless $caller =~ /$ENV{TRACE}/;
        }
        $caller = "TRACE: [$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;

    }
}
EOF

}


#
# dump()  : thisObjectCode
#
# This is the root expansion code. Calling this on your local PerlObject code
# will go through the work of dumping out the definitions into working Perl code.
# 
sub dump {
    my $this = shift;
    my $ret = "";

    my $ret .= $this->newObject();
    $ret .= $this->constructor() unless $this->{noConstructor};

#
# Process All "valid data items"
#

    $ret .= $this->generateMembers($member);
    $ret .= $this->dumpStandardSetters();
    $ret .= $this->generateInterface();
    $ret .= $this->debugPrint();
    $ret .= $this->trace() if $this->{traceOn};
    if ($this->{where}) {
	$ret .= "
=pod

=head1 FILES

  $this->{where}

=cut
";
    }

    $ret .= $this->finish();

    $ret;
}

1;

#
#  TODO : "required" data for the constructor.
#  
=pod

=head2 TODO

- @ISA management
- setter and getter validation of types
- static data for validation of a "valid" method
- 

=cut

#
