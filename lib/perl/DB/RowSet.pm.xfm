<: #-*- perl -*- 

# gpl
# 
#  Author: Renwix (renwix@gmail.com)
#  Maintainer: Renwix
#  Copyright (C) 2008 Renwix, all rights reserved.
#  Created: Tue Sep 23 23:52:17 MDT 2008
# 
# 
#=======================================================================
# 
# This file is part of theSiliProject, a humorous software organization,
# design and development toolkit.
# 
# theSiliProject is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# theSiliProject is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with theSiliProject. If not, see <http://www.gnu.org/licenses/>.
# 
#=======================================================================
# 
# /gpl

# $xfmpipe = [{command => "pp.pl" }];
use Helpers::PerlObject; 

my $po = Helpers::PerlObject->new (name => "DB::RowSet",
				   include => ['DBI'],
				   example => q{
   use DB::OracleHandle;
   use DB::RowSet;
   
   my $dbhandle = DB::OracleHandle->new(user => "$ENV{DB_USER}",
                                        password => "$ENV{DB_PASSWD}",
                                        SID => "$ENV{DB_SID}",
                                        host => "$ENV{DB_HOST}",
                                        port => "$ENV{DB_PORT}");
   
   
   my $rowset = DB::RowSet->new(dbh => $dbhandle->getDbh(),
      			        sql => $this->getSql());
   
   my %results = %{$rowset->getResults()};

   #
   # Or all as one.....
   #

   my %results = %{(DB::RowSet->new(dbh => $dbhandle->getDbh(),
   			            sql => $this->getSql()))->getResults()};


   #
   # Or use the ADO interface
   while ($rowset->next) {
       $data1 = $rowset->item(0);
       $data2 = $rowset->item('jazz');
   }


                                   },
				   description => "A row set returned by a SQL query.");

$po->setMembers([{name => "results", ref => "HASH",
		  description => "results returned by the SQL query"},
		 {name => "rows", format => '\d+',
		  description => "number of the rows in the rowset"},
		 {name => "fields", ref => "ARRAY",
		  description => "An array of field names returned by the SQL query"},
		 {name => "dbh", ref => "DBI::db", 
		  description => "the DBI handle for the database",},
		 {name => "sql", 
		  description => "sql string for this rowset" },
		 {name => "verbose", 
		  description => "verbose STDERR logging of sql queries"},
                 { name => 'i_internal',
                   description => 'Internal variable for storing the current row that is pointed to in the RowSet' },
                 { name => 'nextCalledOnceInternal',
                   description => 'Internal variable for storing the fact that the next function has set the iterator - support for different call syntax based on 1 row in the result set and many rows in the result set.' },
		 ]); 

:>

<:= $po->dump(); :>

sub _new {
<:= $po->dumpContract(method => "_new"); :>
    do {
        $this->execute() if $this->getDbh && $this->getSql;
        $this->reset();
    };
}

sub execute {
    <:= $po->contract("execute" => {description => "execute the sql query as returned by getSql()",
				    getopts => [{name => 'sql',
                                                 description => 'Change the sql on the fly'}
                                                ]}); :>
    do {
        $this->setSql( $sql ) if $sql;                                            
        my $results = {};
        my $verbose = $this->getVerbose();
        my $dbh = $this->getDbh();
        
        my $stmt = $dbh->prepare($this->getSql()) or Confess "ERROR: preparing statement: $DBI::errstr";
        $this->debugPrint(1, "SQL: " . $this->getSql());

        $stmt->execute or Confess "ERROR: $DBI::errstr";
        return if $this->getSql =~ /^\s*(insert|update|delete)/;

        #
        # If there was a dataset returned, then load it
        # 
        my (@row,$debugString);
        
        $results->{rows} = 0;
        $debugString = "\n";
        for (my $i = 0; $i < $stmt->{NUM_OF_FIELDS}; $i++) {
            push (@{$results->{_fields}},$stmt->{NAME}->[$i]);
            $debugString .= $stmt->{NAME}->[$i] . "\t";
        }
        $debugString .= "\n";
        while (@row = $stmt->fetchrow_array()) {
            $results->{rows}++;
            for (my $i = 0; $i < $stmt->{NUM_OF_FIELDS} ; $i++) {
                push (@{$results->{$stmt->{NAME}->[$i]}},$row[$i]);
                $debugString .=  $row[$i] . "\t";
            }
            $debugString .= "\n";
        }
        $this->debugPrint(2, $debugString);
        $stmt->finish;

        $this->setRows($results->{rows});
        $this->setFields($results->{_fields});

        $this->setResults($results);
    };
}

sub loadFromText {
    <:= $po->contract( loadFromText => { description => q[ Given a block of text, try to build a RowSet object off of it. Header is required, \n is line separator.],
                                         getopts => [{ name => 'text',
                                                       required => 1,
                                                       description => 'The text that should be parsed into a rowset object' },
                                                     { name => 'fieldSeparator',
                                                       required => 1,
                                                       description => 'The regexp that is used to break up fields' }] } ) :>
    do {
        my $results = {};
        my ($header, @lines) = split /\n/, $text;
        my @headers = split /$fieldSeparator/, $header;
        
        $results->{rows} = scalar @lines;
        for my $h (@headers) {
            push @{ $results->{_fields} }, uc $h;
            $this->debugPrint(1,  "parsed header field: " . uc $h);
        }
        
        for my $line (@lines) {
            my @fields = split /$fieldSeparator/, $line;
            for (my $i = 0; $i < @fields; $i++) {
                $this->debugPrint(1, "pushing $headers[$i] ~ $fields[$i]");
                push @{ $results->{ uc $headers[$i] } }, $fields[$i] if defined $fields[$i];

            }
        }

        $this->setRows( $results->{rows} );
        $this->setFields( $results->{_fields} );
        $this->setResults( $results );
        $this->debugPrint(1, "Finished building RowSet for textual table data");
    };
}

sub loadFromTableStruct {
    <:= $po->contract( loadFromText => { description => q[ Given a list of header fields, and a hash with id as key, and array ref as the values, build a RowSet object.],
                                         getopts => [{ name => 'headers',
                                                       ref => 'ARRAY',
                                                       required => 1,
                                                       description => 'headers for the object- should correspond to the rows in the values of the hash' },
                                                     { name => 'table',
                                                       ref => 'HASH',
                                                       required => 1,
                                                       description => 'Hash of ids (keys) to values in array ref. Order of values should be the same as the headers' },
                                                     { name => 'preserveCase',
                                                       default => 0,
                                                       description => 'Preserve the case of the field names' },
                                                     { name => 'sortFn',
                                                       default => 'sub { $a <=> $b }',
                                                       ref => 'CODE',
                                                       description => 'Override the sorting function with your own value. Default is numberic sort' },
                                                     ] } ) :>
    do {

        # uc my headers
        my @headers = ();
        if ($preserveCase) {
            @headers = @$headers;
        } else {
            @headers = map { uc } @$headers;
        }
        my $results = {};
        $results->{rows} = keys %$table;
        $results->{_fields} = \@headers;

#        print STDERR Dumper($table);
        
        for my $id (sort { $sortFn->() } keys %$table) {

#            print STDERR "working with $id and ", Dumper($table->{$id});
#             push @{ $results->{ $keyLabel } }, $id if defined $id;

            my @fields = @{ $table->{$id} };
            for (my $i = 0; $i < @fields; $i++) {
                $this->debugPrint(1, "pushing " . $results->{_fields}->[$i] . " ~ $fields[$i]");
#                print STDERR "pushing " . $results->{_fields}->[$i] . " ~ $fields[$i]";
                if ($preserveCase) {
                    push @{ $results->{ $results->{_fields}->[$i] } }, $fields[$i]; # if defined $fields[$i];
                } else {
                    push @{ $results->{ uc $results->{_fields}->[$i] } }, $fields[$i]; # if defined $fields[$i];
                }
            }
        }

#        unshift @headers, $keyLabel;


        $this->setRows( $results->{rows} );
        $this->setFields( $results->{_fields} );
        $this->setResults( $results );
        $this->debugPrint(1, "Finished building RowSet for structured table data");
    };
}


sub reset {
    <:= $po->contract( 'reset' => { description => 'Start at the beginning of the RowSet' } ) :>

    do { # emacs quoting
        $this->{i_internal} = -1;
         $this->{nextCalledOnceInternal} = 0;
    };
}


sub next {
    <:= $po->contract( 'next' => { description => 'get the next row in the RowSet' } ) :>

    do { # emacs quoting
        $this->{nextCalledOnceInternal} = 1;
        $this->{i_internal}++;
        
        if ($this->{i_internal} >= $this->getRows) {
            return 0;
        } else {
            return 1;
        }
    };
}

sub item {
    <:= $po->contract( 'item' => { description => 'Get the data given a field name or a field index',
                                   positionalParameters => 1
                                   } ) :>

    do { # emacs quoting
        $this->{i_internal} = 0 unless $this->{nextCalledOnceInternal};
        my $fieldName = shift;
        if ($fieldName =~ /^\d+$/) { # if it is a digit, lookup the field name
            $fieldName = ( @{ $this->getFields } )[$fieldName];
            $this->debugPrint(1, "Derived '$fieldName' from its index in the field list");
        }
        $this->debugPrint(2, "getting value for $fieldName: " , $this->{results}->{$fieldName}->[$this->{i_internal}]);
        return $this->{results}->{$fieldName}->[$this->{i_internal}];
    };        
}

sub fields {
    <:= $po->contract( 'fields' => { description => 'Get the list of fields' } ) :>
    do {
        return @{ $this->getFields };
    };
}

sub count {
    <:= $po->contract( count => { description => 'Get the count of records in the RecordSet' } ) :>
    return $this->{results}->{rows};
}
